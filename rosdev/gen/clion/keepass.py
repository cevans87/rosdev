from __future__ import annotations
from atools import memoize
from base64 import b64decode, b64encode
# noinspection PyPackageRequirements
from Crypto import Random
# noinspection PyPackageRequirements
from Crypto.Cipher import AES
# noinspection PyPackageRequirements
from Crypto.Util import Padding
from logging import getLogger
import os
from pathlib import Path
from pykeepass import PyKeePass
from textwrap import dedent

from rosdev.gen.clion.underlay import Underlay
from rosdev.util.handler import Handler


log = getLogger(__name__)


@memoize
class Keepass(Handler):

    @property
    def path_base(self) -> str:
        return Underlay(self.options).config_path

    @property
    def c_kdbx_path(self) -> str:
        return f'{self.path_base}/c.kdbx'

    @property
    def c_pwd_path(self) -> str:
        return f'{self.path_base}/c.pwd'

    @property
    def c_pwd_contents(self) -> bytes:
        try:
            with open(self.c_pwd_path, 'rb') as c_pwd_f_in:
                return c_pwd_f_in.read().strip()
        except FileNotFoundError:
            return dedent(f'''
                encryption: BUILT_IN
                isAutoGenerated: false
                value: !!binary {self._make_encoded()}
            ''').strip().encode()

    @property
    def encoded(self) -> bytes:
        return self.c_pwd_contents.split()[-1]

    @property
    def data(self) -> bytes:
        return b64decode(self.encoded)

    @property
    def iv_len(self) -> int:
        return (
                (self.data[0] << 24) +
                (self.data[1] << 16) +
                (self.data[2] << 8) +
                (self.data[3] << 0)
        )

    @property
    @memoize
    def iv(self) -> bytes:
        return self.data[4:self.iv_len + 4]

    @property
    def cipher(self) -> AES:
        return AES.new(key=b'Proxy Config Sec', mode=AES.MODE_CBC, iv=self.iv)

    @property
    def password(self) -> str:
        return Padding.unpad(
            self.cipher.decrypt(self.data[4 + self.iv_len:]), block_size=16
        ).decode()

    @memoize
    async def _main(self) -> None:
        if not Path(self.c_kdbx_path).is_file():
            await exec(f'cp {Path(__file__).parent}/c.kdbx {self.c_kdbx_path}')

        with PyKeePass(self.c_kdbx_path, password=self.password) as db:
            # TODO remove stale entries
            group = db.find_groups(name='IntelliJ Platform', first=True)
            if group is None:
                group = db.add_group(
                    destination_group=db.root_group,
                    group_name='IntelliJ Platform'
                )

            db.add_entry(
                destination_group=group,
                title=f'IntelliJ Platform Deployment â€” {self.uuid}',
                username=os.getlogin(),
                password=self.password,
            )

            db.save(self.c_kdbx_path)

    @memoize
    def _make_encoded(self) -> str:
        iv = Random.new().read(AES.block_size)
        cipher = AES.new(key=b'Proxy Config Sec', mode=AES.MODE_CBC, iv=iv)
        return b64encode([
            0, 0, 0, 4,
            *iv,
            *cipher.encrypt(Padding.pad(b'rosdev', block_size=16))
        ])

