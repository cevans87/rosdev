from dataclasses import dataclass, field, replace
from base64 import b64decode, b64encode
# noinspection PyPackageRequirements
from Crypto import Random
# noinspection PyPackageRequirements
from Crypto.Cipher import AES
# noinspection PyPackageRequirements
from Crypto.Util import Padding
from logging import getLogger
import os
from pathlib import Path
from pykeepass import PyKeePass
from textwrap import dedent
from typing import Tuple, Type

from rosdev.gen.idea.base import GenIdeaBase
from rosdev.util.handler import Handler
from rosdev.util.options import Options
from rosdev.util.subprocess import exec


log = getLogger(__name__)


@dataclass(frozen=True)
class GenIdeaKeepass(Handler):

    pre_dependencies: Tuple[Type[Handler], ...] = field(init=False, default=(
        GenIdeaBase,
    ))

    @classmethod
    async def resolve_options(cls, options: Options) -> Options:
        idea_c_pwd_universal_path = options.resolve_path(
            options.idea_c_pwd_universal_path
        )

        idea_c_kdbx_universal_path = options.resolve_path(
            options.idea_c_kdbx_universal_path
        )
        
        return replace(
            options,
            idea_c_pwd_universal_path=idea_c_pwd_universal_path,
            idea_c_kdbx_universal_path=idea_c_kdbx_universal_path,
        )

    # noinspection PyUnusedLocal
    @classmethod
    def get_encoded(cls, options: Options) -> str:
        iv = Random.new().read(AES.block_size)
        cipher = AES.new(key=b'Proxy Config Sec', mode=AES.MODE_CBC, iv=iv)
        return b64encode([
            0, 0, 0, 4,
            *iv,
            *cipher.encrypt(Padding.pad(b'rosdev', block_size=16))
        ])

    @classmethod
    def get_c_pwd_contents(cls, options: Options) -> bytes:
        try:
            with open(str(options.idea_c_pwd_universal_path), 'rb') as c_pwd_f_in:
                return c_pwd_f_in.read().strip()
        except FileNotFoundError:
            return dedent(f'''
                encryption: BUILT_IN
                isAutoGenerated: false
                value: !!binary {cls.get_encoded(options)}
            ''').strip().encode()

    @classmethod
    async def main(cls, options: Options) -> None:
        if not options.idea_c_kdbx_universal_path.is_file():
            await exec(f'cp {Path(__file__).parent}/c.kdbx {options.idea_c_kdbx_universal_path}')

        c_pwd_contents = cls.get_c_pwd_contents(options)
        data = b64decode(c_pwd_contents.split()[-1])
        iv_len = (
                (data[0] << 24) +
                (data[1] << 16) +
                (data[2] << 8) +
                (data[3] << 0)
        )

        iv = data[4:iv_len + 4]
        cipher = AES.new(key=b'Proxy Config Sec', mode=AES.MODE_CBC, iv=iv)
        password = Padding.unpad(cipher.decrypt(data[4 + iv_len:]), block_size=16).decode()
        with PyKeePass(str(options.idea_c_kdbx_universal_path), password=password) as db:
            # TODO remove stale entries
            group = db.find_groups(name='IntelliJ Platform', first=True)
            if group is None:
                group = db.add_group(
                    destination_group=db.root_group,
                    group_name='IntelliJ Platform'
                )

            db.add_entry(
                destination_group=group,
                title=f'IntelliJ Platform Deployment â€” {options.idea_uuid}',
                username=os.getlogin(),
                password=password,
            )

            db.save(str(options.idea_c_kdbx_universal_path))
