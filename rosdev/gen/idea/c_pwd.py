from dataclasses import dataclass
from base64 import b64decode, b64encode
# noinspection PyPackageRequirements
from Crypto import Random
# noinspection PyPackageRequirements
from Crypto.Cipher import AES
# noinspection PyPackageRequirements,PyProtectedMember
from Crypto.Cipher._mode_cbc import CbcMode
# noinspection PyPackageRequirements
from Crypto.Util import Padding
from logging import getLogger
from textwrap import dedent

from rosdev.gen.idea.home import GenIdeaHome
from rosdev.util.atools import memoize
from rosdev.util.handler import Handler
from rosdev.util.options import Options
from rosdev.util.path import Path

log = getLogger(__name__)


@dataclass(frozen=True)
class GenIdeaCPwd(Handler):

    @classmethod
    @memoize
    async def get_cipher(cls, options: Options) -> CbcMode:
        cipher = AES.new(key=b'Proxy Config Sec', mode=AES.MODE_CBC, iv=await cls.get_iv(options))

        log.debug(f'{cls.__name__} {cipher = }')

        return cipher

    # noinspection PyUnusedLocal
    @classmethod
    @memoize
    async def get_decoded_data(cls, options: Options) -> bytes:
        if (await cls.get_path(options)).is_file():
            decoded_data = b64decode((await cls.get_path(options)).read_bytes().strip().split()[-1])
        else:
            iv = Random.new().read(AES.block_size)
            cipher = AES.new(key=b'Proxy Config Sec', mode=AES.MODE_CBC, iv=iv)
            decoded_data = b64decode(b64encode(bytes([
                0, 0, 0, 16,
                *iv,
                *cipher.encrypt(Padding.pad(b'rosdev', block_size=16))
            ])))
            assert iv == decoded_data[4:20]

        assert (
                (
                        (decoded_data[0] << 24) +
                        (decoded_data[1] << 16) +
                        (decoded_data[2] << 8) +
                        (decoded_data[3] << 0)
                ) == 16
        ), 'Expected decoded data to have iv_len field with value 16'

        log.debug(f'{cls.__name__} {decoded_data = }')

        return decoded_data

    @classmethod
    @memoize
    async def get_encoded_data(cls, options: Options) -> bytes:
        encoded_data = b64encode(await cls.get_decoded_data(options))
        
        log.debug(f'{cls.__name__} {encoded_data = }')
        
        return encoded_data

    @classmethod
    @memoize
    async def get_iv(cls, options: Options) -> bytes:
        iv = (await cls.get_decoded_data(options))[4:20]

        log.debug(f'{cls.__name__} {iv = }')

        return iv

    # noinspection PyUnusedLocal
    @classmethod
    @memoize
    async def get_path(cls, options: Options) -> Path:
        path = await GenIdeaHome.get_path(options) / 'c.pwd'
        
        log.debug(f'{cls.__name__} {path = }')
        
        return path

    @classmethod
    @memoize
    async def get_password(cls, options: Options) -> str:
        password = Padding.unpad(
            (await cls.get_cipher(options)).decrypt((await cls.get_decoded_data(options))[20:]),
            block_size=16,
        ).decode()

        log.debug(f'{cls.__name__} {password}')

        return password
    
    @classmethod
    @memoize
    async def get_bytes(cls, options: Options) -> bytes:
        # noinspection PyShadowingBuiltins
        bytes = dedent(f'''
            encryption: BUILT_IN
            isAutoGenerated: false
            value: !!binary {(await cls.get_encoded_data(options)).decode()}
        ''').strip().encode()
        
        log.debug(f'{cls.__name__} {bytes = }')
        
        return bytes

    @classmethod
    async def main(cls, options: Options) -> None:
        (await cls.get_path(options)).write_bytes(await cls.get_bytes(options))
